/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include <math.h> 

#include "gsl/gsl_sf_bessel.h"

#include "TMath.h"

#include "RooAbsReal.h" 
#include "P2VV/RooIpatia2.h" 

const Double_t sq2pi = sqrt(2*acos(-1.0));
const Double_t sq2pi_inv = 1./sq2pi;
const Double_t logsq2pi = log(sq2pi);
const Double_t log_de_2 = log(2.0);

Double_t low_x_BK(Double_t nu,Double_t x){
  return TMath::Gamma(nu)*pow(2,nu-1)*pow(x,-nu);
}


Double_t low_x_LnBK(Double_t nu, Double_t x){
  return log(TMath::Gamma(nu)) + (nu-1)*log_de_2 - nu * log(x);
}

Double_t BK(Double_t ni, Double_t x) {
  Double_t nu = abs(ni);
  if ( x < 1e-06 && nu > 0) return low_x_BK(nu,x);
  if ( x < 1e-04 && nu > 0 && nu < 55) return low_x_BK(nu,x);
  if ( x < 0.1 && nu >= 55) return low_x_BK(nu,x);

  return gsl_sf_bessel_Knu(nu, x);
}

Double_t LnBK(double ni, double x) {
  Double_t nu = abs(ni);
  if ( x < 1e-06 && nu > 0) return low_x_LnBK(nu,x);
  if ( x < 1e-04 && nu > 0 && nu < 55) return low_x_LnBK(nu,x);
  if ( x < 0.1 && nu >= 55) return low_x_LnBK(nu,x);

  return gsl_sf_bessel_lnKnu(nu, x);
}


Double_t LogEval(Double_t d, Double_t l, Double_t alpha, Double_t beta, Double_t delta) {
  //Double_t d = x-mu;
  //Double_t sq2pi = sqrt(2*acos(-1));
  Double_t gamma = alpha;//sqrt(alpha*alpha-beta*beta);
  Double_t dg = delta*gamma;
  Double_t thing = delta*delta + d*d;
  Double_t logno = l*log(gamma/delta) - logsq2pi -LnBK(l, dg);
  
  return exp(logno + beta*d +(0.5-l)*(log(alpha)-0.5*log(thing)) + LnBK(l-0.5,alpha*sqrt(thing)));// + log(abs(beta)+0.0001) );

}


Double_t diff_eval(Double_t d, Double_t l, Double_t alpha, Double_t beta, Double_t delta){
  //Double_t sq2pi = sqrt(2*acos(-1));
  //Double_t cons1 = 1./sq2pi;
  Double_t gamma = alpha;// sqrt(alpha*alpha-beta*beta);
  Double_t dg = delta*gamma;
  //Double_t mu_ = mu;// - delta*beta*BK(l+1,dg)/(gamma*BK(l,dg));
  //Double_t d = x-mu;
  Double_t thing = delta*delta + d*d;
  Double_t sqthing = sqrt(thing);
  Double_t alphasq = alpha*sqthing;
  Double_t no = pow(gamma/delta,l)/BK(l,dg)*sq2pi_inv;
  Double_t ns1 = 0.5-l;
  //Double_t cheat = exp(beta*d);//*(abs(beta) + 1e-04);
  //Double_t cheat = exp(beta*d);//*(abs(beta) + 0.0001);

  //no =  no*pow(alpha, ns1 )*pow(thing, 0.5*l - 5.0/4.0)*0.5*cheat;//exp(beta*d);

  //return no*(-alphasq*d* (BK(l - 3.0/2.0, alphasq) - BK(l + 0.5, alphasq)) + (2*beta*thing + 2*d*l - d)*BK(-ns1, alphasq));
  //return no*pow(alpha, -l + 1.0/2.0)*pow(thing, l/2 - 5.0/4.0)*(-d*alphasq*BK(l - 3.0/2.0, alphasq) - d*alphasq*BK(l + 1.0/2.0, alphasq) + 2*beta*thing*BK(l - 0.5, alphasq) + 2*d*l*BK(l - 0.5, alphasq) - d*BK(l - 0.5, alpha*sqthing))*exp(beta*d)/2;
  
  return no*pow(alpha, ns1)*pow(thing, l/2 - 5.0/4.0)*(-d*alphasq*(BK(l - 3.0/2.0, alphasq) + BK(l + 0.5, alphasq)) + (2*(beta*thing + d*l) - d)*BK(ns1, alphasq))*exp(beta*d)/2;
}

// Double_t diff_eval_check(Double_t d, Double_t l, Double_t alpha, Double_t beta, Double_t delta){
  
//   Double_t gamma = alpha;//sqrt(alpha*alpha-beta*beta);
//   Double_t dg = delta*gamma;
  
//   Double_t thing = delta*delta + d*d;
//   Double_t sqthing = sqrt(thing);
//   Double_t alphasq = alpha*sqthing;
//   Double_t no = pow(gamma/delta,l)/BK(l,dg)*sq2pi_inv;

//   return no*pow(alpha, -l + 1.0/2.0)*pow(pow(d, 2) + pow(delta, 2), l/2 - 5.0/4.0)*(-alpha*d*sqrt(pow(d, 2) + pow(delta, 2))*BK(l - 3.0/2.0, alpha*sqrt(pow(d, 2) + pow(delta, 2))) - alpha*d*sqrt(pow(d, 2) + pow(delta, 2))*BK(l + 1.0/2.0, alpha*sqrt(pow(d, 2) + pow(delta, 2))) + 2*beta*(pow(d, 2) + pow(delta, 2))*BK(l - 1.0/2.0, alpha*sqrt(pow(d, 2) + pow(delta, 2))) + 2*d*l*BK(l - 1.0/2.0, alpha*sqrt(pow(d, 2) + pow(delta, 2))) - d*BK(l - 1.0/2.0, alpha*sqrt(pow(d, 2) + pow(delta, 2))))*exp(beta*d)/2;
// }

 

 RooIpatia2::RooIpatia2(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _l,
                        RooAbsReal& _zeta,
                        RooAbsReal& _fb,
                        RooAbsReal& _sigma,
                        RooAbsReal& _mu,
                        RooAbsReal& _a,
                        RooAbsReal& _n,
                        RooAbsReal& _a2,
                        RooAbsReal& _n2) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   l("l","l",this,_l),
   zeta("zeta","zeta",this,_zeta),
   fb("fb","fb",this,_fb),
   sigma("sigma","sigma",this,_sigma),
   mu("mu","mu",this,_mu),
   a("a","a",this,_a),
   n("n","n",this,_n),
   a2("a2","a2",this,_a2),
   n2("n2","n2",this,_n2)
 { 
 } 


 RooIpatia2::RooIpatia2(const RooIpatia2& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   l("l",this,other.l),
   zeta("zeta",this,other.zeta),
   fb("fb",this,other.fb),
   sigma("sigma",this,other.sigma),
   mu("mu",this,other.mu),
   a("a",this,other.a),
   n("n",this,other.n),
   a2("a2",this,other.a2),
   n2("n2",this,other.n2)
 { 
 } 



 Double_t RooIpatia2::evaluate() const 
 { 
   Double_t d = x-mu;
   Double_t cons0 = sqrt(zeta);
   Double_t alpha, beta, delta,  cons1, phi, A, B, k1, k2;
   Double_t asigma = a*sigma;
   Double_t a2sigma = a2*sigma;
   Double_t out = 0.0;
   if (zeta!= 0.) {
     phi = BK(l+1,zeta)/BK(l,zeta); // careful if zeta -> 0. You can implement a function for the ratio, but carefull again that |nu + 1 | != |nu| + 1 so you jave to deal wiht the signs
     cons1 = sigma/sqrt(phi);
     alpha  = cons0/cons1;//*sqrt((1 - fb*fb));
     beta = fb;//*alpha;
     delta = cons0*cons1;
     
     if (d < -asigma){
       //printf("-_-\n");
       //printf("alpha %e\n",alpha);
       //printf("beta %e\n",beta);
       //printf("delta %e\n",delta);
       
       k1 = LogEval(-asigma,l,alpha,beta,delta);
       k2 = diff_eval(-asigma,l,alpha,beta,delta); 
       B = -asigma + n*k1/k2;
       A = k1*pow(B+asigma,n);
       //printf("k1 is %e\n",k1);
       //printf("k2 is %e\n",k2);
       //printf("A is%e\n",A);
       //printf("B is%e\n",B);
       out = A*pow(B-d,-n);
     }
     else if (d>a2sigma) {
       //printf("uoeo\n");
       k1 = LogEval(a2sigma,l,alpha,beta,delta);
       k2 = diff_eval(a2sigma,l,alpha,beta,delta);
       
       B = -a2sigma - n2*k1/k2;
       
       A = k1*pow(B+a2sigma,n2);
       
       out =  A*pow(B+d,-n2);
       
     }
     else {
       //printf("HERE\n");
       out = LogEval(d,l,alpha,beta,delta);
     }
     


   }
   else if (l < 0) {
     beta = fb;
     cons1 = -2*l;
     delta = sigma;
     if (d < -asigma ) {
       cons1 = exp(-beta*asigma);
       phi = 1 + a*a;
       k1 = cons1*pow(phi,l-0.5);
       k2 = beta*k1- cons1*(l-0.5)*pow(phi,l-1.5)*2*a/delta;
       B = -asigma + n*k1/k2;
       A = k1*pow(B+asigma,n);
       out = A*pow(B-d,-n);
     }
     else if (d > a2sigma) {
       cons1 = exp(beta*a2sigma);
       phi = 1 + a2*a2;
       k1 = cons1*pow(phi,l-0.5);
       k2 = beta*k1+ cons1*(l-0.5)*pow(phi,l-1.5)*2*a2/delta;
       B = -a2sigma - n2*k1/k2;
       A = k1*pow(B+a2sigma,n2);
       out =  A*pow(B+d,-n2);
       
     }
     else { out = exp(beta*d)*pow(1 + d*d/(delta*delta),l-0.5);}
   }
   else {
     //printf("zeta = 0 only suported for l < 0, while l = %e\n",0);
   }
   //printf("result is %e\n",out);
   return out;
 } 



